;
; Copyright (c) 2020 Raspberry Pi (Trading) Ltd.
;
; SPDX-License-Identifier: BSD-3-Clause
;

.program adb_write
.side_set 1

.define public T1 2
.define public T2 5
.define public T3 3

.define HIGH 1
.define LOW 0

.define public T35US 6
.define public T30US 5

.lang_opt python sideset_init = pico.PIO.OUT_HIGH
.lang_opt python out_init     = pico.PIO.OUT_HIGH
.lang_opt python out_shiftdir = 1

bitloop:
    ; out will block until data is available
 ;   out x, 1       side HIGH [T3 - 1] ; Side-set still takes place when instruction stalls
    nop   side LOW [10-1]
    nop   side HIGH [10-1]
;    nop   side LOW
;    nop   side HIGH
;    jmp !x do_zero           [T1 - 1] ; Branch on the bit we shifted out. Positive pulse
;do_one:
 ;   jmp  bitloop   side HIGH [T2 - 1] ; Continue driving high, for a long pulse
 ;   nop            side LOW [T2 - 1] ; Or drive low, for a short pulse
;do_zero:
 ;   nop            side LOW [T2 - 1] ; Or drive low, for a short pulse
 ;   nop            side LOW [T2 - 1] ; Or drive low, for a short pulse
.wrap


; inline bool AdbInterface::place_bit0(void)
; {
;   data_lo();
;   adb_delay_us(65);
;   data_hi();
;   return adb_delay_us(35);
; }
; inline bool AdbInterface::place_bit1(void)
; {
;   data_lo();
;   adb_delay_us(35);
;   data_hi();
;   return adb_delay_us(65);
; }
; bool AdbInterface::send_byte(uint8_t data)
; {
;   for (int i = 0; i < 8; i++)
;   {
;     if (data & (0x80 >> i))
;     {
;       if(!place_bit1()) return false;
;     }
;     else
;     {
;       if(!place_bit0()) return false;
;     }
;   }
;   return true;
; }

;    out x, 1       side 1 [T3 - 1] ; Side-set still takes place when instruction stalls


;do_nack:
;    jmp y-- entry_point        ; Continue if NAK was expected
;    irq wait 0 rel             ; Otherwise stop, ask for help


; <instruction> (side <side_set_value>) ([<delay_value>])
;.wrap_target
;do_byte:
;    pull block   side HIGH                  ; Load a 32-bit word from the TX FIFO into the OSR. Block on empty
;    set x, 15               ; Loop 8 times (x = 8)

;bitloop:
;    nop       side HIGH [T35US]
;    out pins, 1      [T30US]      ; Shift 1 bit from OSR to the first OUT pin
;    nop       side LOW [T35US-1]
;    jmp x-- bitloop               ; Each loop iteration is 8 cycles.#
;.wrap ; automatically wraps to do_byte
;



;# Low for 35us
;#shift out lsb and wait 30us
;# Set high for 35us
;#### x = (OSR & 0x1)
;####  data_lo();(through side set)#
;    out pins, 1            ; Shift 1 bit from OSR to the first OUT pin#
;
;    jmp !x do_zero                 ; Branch on the bit we shifted out. Positive pulse#
;do_one:
;####  adb_delay_us(65);
;####  data_hi();
;    nop                   [T2 - 1] ; Delay 65ms
;    nop            side 0 [T2 - 1] ; Delay 35ms#
;
;
;    jmp  bitloop   side 1 [T2 - 1] ; Continue driving high, for a long pulse
;do_zero:
;####  adb_delay_us(65);
;####  data_hi();
;    nop                   [T2 - 1] ; Delay 65ms
;    nop            side 0 [T2 - 1] ; Delay 35ms
;    jmp x-- bitloop   [6]  ; Each loop iteration is 8 cycles.#
;
;    nop            side 0 [T2 - 1] ; Or drive low, for a short pulse#
;.wrap
;bitloop:
;    out pindirs, 1         [7] ; Serialise write data (all-ones if reading)
;    nop             side 1 [2] ; SCL rising edge
;    wait 1 pin, 1          [4] ; Allow clock to be stretched
;    in pins, 1             [7] ; Sample read data in middle of SCL pulse
;    jmp x-- bitloop side 0 [7] ; SCL falling edge#
;
;    ; Handle ACK pulse
;    out pindirs, 1         [7] ; On reads, we provide the ACK.
;    nop             side 1 [7] ; SCL rising edge
;    wait 1 pin, 1          [7] ; Allow clock to be stretched
;    jmp pin do_nack side 0 [2] ; Test SDA for ACK/NAK, fall through if ACK#
;
;public entry_point:
;.wrap_target
;    out x, 6                   ; Unpack Instr count
;    out y, 1                   ; Unpack the NAK ignore bit
;    jmp !x do_byte             ; Instr == 0, this is a data record.
;    out null, 32               ; Instr > 0, remainder of this OSR is invalid
;do_exec:
;    out exec, 16               ; Execute one instruction per FIFO word
;    jmp x-- do_exec            ; Repeat n + 1 times




;###.wrap_target
;###bitloop:
;###    out x, 1       side 0 [T3 - 1] ; Side-set still takes place when instruction stalls
;###    jmp !x do_zero side 1 [T1 - 1] ; Branch on the bit we shifted out. Positive pulse
;###do_one:
;###    jmp  bitloop   side 1 [T2 - 1] ; Continue driving high, for a long pulse
;###do_zero:
;###    nop            side 0 [T2 - 1] ; Or drive low, for a short pulse
;###.wrap

% c-sdk {
#include "hardware/clocks.h"

static inline void adb_write_program_init(PIO pio, uint sm, uint offset, uint pin, float freq, bool rgbw) {

    pio_gpio_init(pio, pin);
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, true);

    pio_sm_config c = adb_write_program_get_default_config(offset);
    sm_config_set_sideset_pins(&c, pin);

    sm_config_set_out_pins(&c, pin, 1);

//c	Pointer to the configuration structure to modify
//shift_right	true to shift OSR to right, false to shift OSR to left
//autopull	whether autopull is enabled
//pull_threshold	threshold in bits to shift out before auto/conditional re-pulling of the OSR
    sm_config_set_out_shift(&c, true, true, 16);
 
    int cycles_per_bit = adb_write_T35US + adb_write_T30US + adb_write_T35US;
    float div = clock_get_hz(clk_sys) / (freq * cycles_per_bit*10);

    // We want each "tick" in the pio controller to be 5us
    // This equates to 200000 ticks per second
    printf("clock_get_hz: %d freq: %f  cycles_per_bit: %d  div: %f\n", clock_get_hz(clk_sys), freq, cycles_per_bit, div);
    sm_config_set_clkdiv(&c, 625);

    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}
%}
